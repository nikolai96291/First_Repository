#include <iostream>
using namespace std;

class AbstractMatrix
{
protected:
	int n;
	int m;
	float* data;
public:
	virtual AbstractMatrix& operator+(AbstractMatrix&) = 0;
	//virtual AbstractMatrix& operator*(AbstractMatrix&) = 0;
	virtual AbstractMatrix& operator*(int&) = 0;
	virtual AbstractMatrix& operator-(AbstractMatrix&) = 0;
	//virtual AbstractMatrix& reverse() = 0;
	//virtual AbstractMatrix& transpose() = 0;
	//virtual float determinant() = 0;
	virtual ostream& print(ostream& o) = 0;
	virtual istream& read(istream& o) = 0;
	virtual void set(int i, int j, float data) = 0;
	virtual float get(int i, int j) = 0;
	virtual int getN() = 0;
	virtual int getM() = 0;
	virtual bool failed() = 0;
};
class matrix : public AbstractMatrix
{
public:
	matrix()
	{
		this->n = 0;
		this->m = 0;
		this->data = NULL;
	}
	matrix(const matrix& a)
	{}
	~matrix()
	{}
	AbstractMatrix& operator*(AbstractMatrix& a)
	{	
		matrix* c = new matrix;
		if (this->getM() == a.getN())
		{
			float k = 0;
			c->n = this->getN();
			c->m = a.getM();
			c->data = new float[this->getN()*a.getM()];
			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < m; j++)
				{
					for (int p = 0; p < this->getN(); p++)
						k = k + this->get(i,p)*a.get(j,p);
					c->set(i, j, k);
					cout << k<<endl;
					k = 0;
				}
			}
			return(*c);
		}
		else
		{
			//c->n = 0;
		//	c->m = 0;
	//		c->data = NULL;
			return(*c);
		}
	}
	AbstractMatrix& operator*(int& k)
	{
		matrix* c = new matrix;
		c->n = this->getN();
		c->m = this->getM();
		c->data = new float[this->getN()*this->getM()];
		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < m; j++)
			{
				c->set(i, j, this->get(i, j)*k);
			}
		}
		return(*c);
	}
	AbstractMatrix& operator+(AbstractMatrix& a)
	{
		matrix* c = new matrix;
		if (this->n == a.getN() && this->m == a.getM())
		{
			c->n = a.getN();
			c->m = a.getM();
			c->data = new float[a.getN()*a.getM()];
			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < m; j++)
				{
					c->set(i, j, this->get(i, j) + a.get(i, j));
				}
			}
			return(*c);
		}
		else
		{
			c->n = 0;
			c->m = 0;
			c->data = NULL;
			return(*c);
		}
	}
	AbstractMatrix& operator-(AbstractMatrix& a)
	{
		matrix* c = new matrix;
		if (this->n == a.getN() && this->m == a.getM())
		{
			c->n = a.getN();
			c->m = a.getM();
			c->data = new float[a.getN()*a.getM()];
			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < m; j++)
				{
					c->set(i, j, this->get(i, j) - a.get(i, j));
				}
			}
			return(*c);
		}
		else
		{
			c->n = 0;
			c->m = 0;
			c->data = NULL;
			return(*c);
		}
	}
	ostream& print(ostream& o)
	{
		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < m; j++)
			{
				o << get(i, j) << ' ';
			}
			o << endl;
		}
		return(o);
	}
	istream& read(istream& o)
	{
		o >> n;
		o >> m;
		data = new float[n*m];
		float tmp;
		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < m; j++)
			{
				o >> tmp;
				set(i, j, tmp);
			}
		}
		return(o);
	}
	void set(int i, int j, float data)
	{
		this->data[i*this->m + j] = data;
	}
	float get(int i, int j)
	{
		return(this->data[i*this->m + j]);
	}
	int getN()
	{
		return(this->n);
	}
	int getM()
	{
		return(this->m);
	}
	bool failed()
	{
		if (this->n == 0 && this->m == 0 && this->data == NULL)
			return true;
		else
			return false;
	}
};
